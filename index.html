<!doctype html>
<html lang="en-US">

<head>
    <meta charset="utf-8" />
    <title>example</title>
</head>

<body>
    <script type="module">
        import init, { compress, decompress, ZstdCompressor, ZstdDecompressor } from "./pkg/web/zstd_wasm_vn.js";

        const encoder = new TextEncoder();
        const decoder = new TextDecoder();

        init().then(() => {
            // =========================== [Smaill Data] ===========================

            const small_data = encoder.encode("Compresses data using Zstandard compression")
            const small_compressed = compress(small_data, undefined);
            const small_decompressed = decompress(small_compressed);

            console.log("data: ", small_data);
            console.log("compressed: ", small_compressed);
            console.log("decompressed: ", small_decompressed);

            try {
                assertTwoByteArraysEqual(small_data, small_decompressed, "Test failed"); // This will throw an error
                console.log("Compress 1 is Ok !");
            } catch (error) {
                console.error(error.message);
            }
            // =========================== [Streaming] ===========================
            // 1. Setup Data
            const long_str = `This is some test data that is intentionally longer to ensure streaming works across 
                If  is {RequestInfo} or {URL}, makes a request and * for everything else, calls  directly.
                Secrets and variables allow you to manage reusable configuration data. Secrets are encrypted and are used for sensitive data. Learn more about encrypted secrets.
                Variables are shown as plain text and are used for non-sensitive data. Learn more about variables. Anyone with collaborator access to this repository can use these 
                secrets and variables for actions. They are not passed to workflows that are triggered by a pull request from a fork.
                multiple blocks, which is necessary to properly test the chunking logic of the ZstdDecompressor implementation.`

            const large_data = encoder.encode(long_str);
            const CHUNK_SIZE = 10;

            console.log("large_data: ", large_data);

            // =========================== [ZstdCompressor] ===========================
            // 2. Setup Compressor
            const compressor = new ZstdCompressor()

            // 3. Stream Compression (chunking logic)
            for (let i = 0; i < large_data.length; i += CHUNK_SIZE) {
                const chunk = large_data.slice(i, i + CHUNK_SIZE);
                // The Wasm binding method signature typically takes a Uint8Array
                compressor.compress_chunk(chunk);
            }

            // 4. Finalize and get compressed data
            const large_compressed = compressor.finalize();
            try {
                console.log("large_compressed: ", large_compressed);
                assertTwoByteArraysEqual(large_data, decompress(large_compressed), "Test failed"); // This will throw an error
                console.log("ZstdCompressor is Ok !");
            } catch (error) {
                console.error(error.message);
            }

            // =========================== [ZstdCompressor] ===========================
            // 2. Setup Decompressor
            const decompressor = new ZstdDecompressor(large_compressed)

            // 4. Stream Decompression (chunking logic)
            const decompressed = [];
            while (true) {
                const chunk = decompressor.decompress_chunk(CHUNK_SIZE);
                // Stop condition: empty chunk (Uint8Array) indicates EOF
                if (chunk.length === 0) {
                    break;
                }
                // Collect the chunk
                decompressed.push(chunk);
            }

            // 5. Concatenate all chunks into a single Uint8Array
            const totalLength = decompressed.reduce((sum, chunk) => sum + chunk.length, 0);
            const finalDecompressed = new Uint8Array(totalLength);
            let offset = 0;
            for (const chunk of decompressed) {
                finalDecompressed.set(chunk, offset);
                offset += chunk.length;
            }

            try {
                console.log("final Decompressed: ", finalDecompressed);
                assertTwoByteArraysEqual(large_data, finalDecompressed, "Test failed"); // This will throw an error
                console.log("ZstdCompressor is Ok !");
            } catch (error) {
                console.error(error.message);
            }
        });

        function assertTwoByteArraysEqual(arr1, arr2, message) {
            if (!(arr1 instanceof Uint8Array) || !(arr2 instanceof Uint8Array)) {
                throw new Error("Both inputs must be Uint8Array instances.");
            }

            if (arr1.length !== arr2.length) {
                throw new Error(message || "Byte arrays have different lengths.");
            }

            for (let i = 0; i < arr1.length; i++) {
                if (arr1[i] !== arr2[i]) {
                    throw new Error(message || `Byte arrays differ at index ${i}.`);
                }
            }
        }
    </script>
</body>

</html>